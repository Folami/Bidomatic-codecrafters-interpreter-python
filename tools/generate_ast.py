#!/usr/bin/env python3
import sys
import os

def main():
    if len(sys.argv) != 2:
        sys.stderr.write("Usage: generate_ast <output directory>\n")
        sys.exit(64)
    output_dir = sys.argv[1]
    types = [
        "Binary   : Expr left, Token operator, Expr right",
        "Grouping : Expr expression",
        "Literal  : Object value",
        "Unary    : Token operator, Expr right"
    ]
    define_ast(output_dir, "Expr", types)

def define_ast(output_dir, base_name, types):
    # Weâ€™ll write to a file named expr.py in the output directory.
    path = os.path.join(output_dir, f"{base_name.lower()}.py")
    with open(path, "w", encoding="utf-8") as writer:
        writer.write("# This file is generated by generate_ast.py. Do not edit.\n")
        writer.write("from dataclasses import dataclass\n")
        writer.write("from token import Token\n\n")
        
        # Write the base AST class.
        writer.write(f"class {base_name}:\n")
        writer.write("    def accept(self, visitor):\n")
        writer.write("        raise NotImplementedError()\n\n")
        
        # Write a Visitor base class with abstract methods.
        define_visitor(writer, base_name, types)
        writer.write("\n")
        
        # Generate each AST type as a dataclass.
        for type_str in types:
            parts = type_str.split(":")
            class_name = parts[0].strip()
            fields = parts[1].strip()
            define_type(writer, base_name, class_name, fields)

def define_visitor(writer, base_name, types):
    writer.write("class Visitor:\n")
    for type_str in types:
        type_name = type_str.split(":")[0].strip()
        # Generate method name like: visit_binary_expr(self, expr)
        method_name = f"visit_{type_name.lower()}_{base_name.lower()}"
        writer.write(f"    def {method_name}(self, {base_name.lower()}):\n")
        writer.write("        raise NotImplementedError()\n")
    writer.write("\n")

def define_type(writer, base_name, class_name, field_list):
    writer.write("@dataclass\n")
    writer.write(f"class {class_name}({base_name}):\n")
    fields = field_list.split(", ")
    for field in fields:
        field_type, field_name = field.split(" ")
        # Convert Java's 'Object' type to Python's 'object'
        if field_type == "Object":
            field_type = "object"
        writer.write(f"    {field_name}: {field_type}\n")
    writer.write("\n")
    writer.write("    def accept(self, visitor):\n")
    method_name = f"visit_{class_name.lower()}_{base_name.lower()}"
    writer.write(f"        return visitor.{method_name}(self)\n")
    writer.write("\n")

if __name__ == "__main__":
    main()
